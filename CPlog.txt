
Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.

You can return the answer in any order.

# Hashtable: One-pass, Make with Find
    def twoSum(self, nums: list[int], target: int) -> list[int]:
        n = len(nums)
        dic = collections.defaultdict(int)
        # O(N)
        for i in range(n):
            complement = target - nums[i]
            if complement in dic:
                return [i, dic[complement]]
            dic[nums[i]] = i


    # Hashtable: Two-pass, Make and Find
    def twoSum(self, nums: list[int], target: int) -> list[int]:
        n = len(nums)
        dic = collections.defaultdict(int)
        # O(N)
        for idx, num in enumerate(nums):
            dic[num] = idx
        
        # O(N)
        for i in range(n):
            complement = target - nums[i]
            if complement in dic:
                if i != dic[complement]:
                    return [i, dic[complement]]
        
    # Brute force, Loop through each element x
    def twoSum(self, nums: list[int], target: int) -> list[int]:
        n = len(nums)
        for i in range(n):
            for j in range(i+1, n):
                if nums[i] + nums[j] == target:
                    return [i, j]


















Given a roman numeral, convert it to an integer.

class Solution:
def romanToInt(self, s: str) -> int:
total = 0
dic = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}

    prev = 0
    curr = 0
    total = 0
    for i in range(len(s)):
        curr = dic[s[i]]
        if curr > prev:
            total = total + curr - 2* prev
        else:
            total = total + curr
        prev=curr
    return total


class Solution:
    def romanToInt(self, s: str) -> int:
        roman={"I":1,"V":5,"X":10,"L":50,"C":100,"D":500,"M":1000}
        val=0
        for i in range(len(s)-1):
            if roman[s[i]]>=roman[s[i+1]]:
                val+=roman[s[i]]
            else:
                val-=roman[s[i]]
        return val+roman[s[-1]]












Merge two sorted linked lists and return it as a sorted list. The list should be made by splicing together the nodes of the first two lists
Example 1:
Input: l1 = [1,2,4], l2 = [1,3,4]
Output: [1,1,2,3,4,4]

my solution: 32ms

class Solution:
    def mergeTwolists(self, l1: listNode, l2: listNode) -> listNode:
        if l1 is None:
            return l2
        if l2 is None:
            return l1
        
        p = l1
        q = l2
        
        if p.val <= q.val:
            ll1 = l1
            p = p.next
        else: 
            ll1 = l2
            q = q.next
        
        prev = ll1
        
        while(True):
            
            if p is None:
                prev.next = q
                break
            elif q is None:
                prev.next = p
                break
            
            if p.val <= q.val:
                prev.next = p
                prev = p
                p = p.next
            else: 
                prev.next = q
                prev = q
                q = q.next

        return ll1


def mergeTwolists(self, l1: listNode, l2: listNode) -> listNode:
	if not l1:
		return l2
	if not l2:
		return l1
	l1listNode = l1
	l2listNode = l2
	resultNode = listNode(0)
	returnHead = resultNode
	while l1listNode and l2listNode:
		if l1listNode.val <= l2listNode.val:
			resultNode.next = l1listNode
			l1listNode = l1listNode.next
		else:
			resultNode.next = l2listNode
			l2listNode = l2listNode.next
		resultNode = resultNode.next


	if not l1listNode and l2listNode:
		resultNode.next = l2listNode
	elif not l2listNode and l1listNode:
		resultNode.next = l1listNode
	return returnHead.next











Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.
Example 1:

Input: nums = [1,3,5,6], target = 5
Output: 2

def searchInsert(self, nums: list[int], target: int) -> int:
        if target <= nums[0]:
            return 0
        if target > nums[-1]:
            return len(nums)
        for i in range(1, len(nums)):
            if nums[i] == target:
                return i
            if nums[i-1] < target < nums[i]:
                return i


Mysolution: 52ms
class Solution:   
 def searchInsert(self, nums: list[int], target: int) -> int:
        for i,num in enumerate(nums):
            if target<=num:
                return i
        return len(nums)














 Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

Clarification:

What should we return when needle is an empty string? This is a great question to ask during an interview.
For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf().
Example 1:

Input: haystack = "hello", needle = "ll"
Output: 2

class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        len_h = len(haystack)
        len_n = len(needle)
        for i in range(len_h - len_n + 1):
            if haystack[i:i+len_n]==needle:
                return i
        return -1











Write a function to find the longest common prefix string amongst an array of strings.
If there is no common prefix, return an empty string "".

Example 1:
Input: strs = ["flower","flow","flight"]
Output: "fl"


my solution:  32ms
class Solution:
    def longestCommonPrefix(self, strs: list[str]) -> str:
        if len(strs)<1:
            return ""
        if len(strs)==1:
            return strs[0]
        for i,char in enumerate(strs[0]):
            for s in strs:
                try:
                    if char != s[i]:
                        return s[:i]
                except:
                    return s[:i]
        return strs[0]


    def longestCommonPrefix(self, strs: list[str]) -> str:
        if not strs:
            return ""
        
        strs.sort()
        
        result = []
        
        for idx, char in enumerate(strs[0]):
            if char == strs[-1][idx]:
                result.append(char)
            else:
                break
        
        return "".join(result)

https://leetcode.com/problems/longest-common-prefix/solution/
4 official solutions










1480. Running Sum of 1d Array
Given an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]â€¦nums[i]).

Return the running sum of nums.

mysol
class Solution:
    def runningSum(self, nums: list[int]) -> list[int]:
        rs = list()
        cs = 0
        for num in nums:
            cs += num
            rs.append(cs)
        return rs

class Solution:
    def runningSum(self, nums: list[int]) -> list[int]:
        output = []
        output.append(nums[0])
        for i in range(1, len(nums)):
            output.append(nums[i] + output[i-1])
        return output












1437. Check If All 1's Are at Least Length K Places Away

Given an array nums of 0s and 1s and an integer k, return True if all 1's are at least k places away from each other, otherwise return False.

mysol 550ms:
class Solution:
    def kLengthApart(self, nums: list[int], k: int) -> bool:
        stack = [-1]*k
        for num in nums:
            if num==1:
                if len(stack)<k:
                    return False
                stack=[]
            else:
                stack.append(0)
        return True


best sol 530ms:

Approach 1: One Pass + Count
Let's first implement a pretty straightforward one-pass idea: to iterate over the array and count the number of zeros in-between the "neighbor" 1s. Each two neighbor 1s should have at least k zeros in-between. If it's not the case, return false.


class Solution:
    def kLengthApart(self, nums: list[int], k: int) -> bool:
        # initialize the counter of zeros to k
        # to pass the first 1 in nums
        count = k
        
        for num in nums:
            # if the current integer is 1
            if num == 1:
                # check that number of zeros in-between 1s
                # is greater than or equal to k
                if count < k:
                    return False
                # reinitialize counter
                count = 0
            # if the current integer is 0
            else:
                # increase the counter
                count += 1
                
        return True


other sol 900ms:
Approach 2: Bit Manipulation
This approach would be more suitable for the Facebook variation of this problem, when the input is not a binary array but an integer.

In this situation, the problem could be solved with the bitwise trick to remove trailing zeros in the binary representation:

# remove trailing zeros
while x & 1 == 0:
    x = x >> 1


Algorithm

1. Convert binary array into integer x. Note that this conversion always works fine in Python where there is no limit on the value of integers. In Java, the usage of this approach is limited by the integer capacity.

2. Consider the base cases: return true if x == 0 or k == 0.

3 .Remove trailing zeros in the binary representation of x. That ensures that the last bit of x is 1-bit.

4. While x is greater than 1:

	Remove trailing 1-bit with the right shift: x >>= 1.

	Remove trailing zeros one by one, and count them using counter count. The number of zeros in-between 1-bits should be greater or equal to k. Hence, return false if count < k.

5. We're here because all 1-bits are separated by more than k zeros. Return true.



class Solution:
    def kLengthApart(self, nums: list[int], k: int) -> bool:
        # convert binary array into int
        x = 0
        for num in nums:
            x = (x << 1) | num
        
        # base case
        if x == 0 or k == 0:
            return True
        
        # remove trailing zeros
        while x & 1 == 0:
            x = x >> 1
        
        while x != 1:
            # remove trailing 1-bit
            x = x >> 1
            
            # count trailing zeros
            count = 0
            while x & 1 == 0:
                x = x >> 1
                count += 1
                
            # number of zeros in-between 1-bits
            # should be greater than or equal to k
            if count < k:
                return False
        
        return True



all three time O(N) and const space































1337. The K Weakest Rows in a Matrix

You are given an m x n binary matrix mat of 1's (representing soldiers) and 0's (representing civilians). The soldiers are positioned in front of the civilians. That is, all the 1's will appear to the left of all the 0's in each row.

A row i is weaker than a row j if one of the following is true:

The number of soldiers in row i is less than the number of soldiers in row j.
Both rows have the same number of soldiers and i < j.
Return the indices of the k weakest rows in the matrix ordered from weakest to strongest.

Example 1:
Input: mat = 
[[1,1,0,0,0],
 [1,1,1,1,0],
 [1,0,0,0,0],
 [1,1,0,0,0],
 [1,1,1,1,1]], 
k = 3
Output: [2,0,3]
Explanation: 
The number of soldiers in each row is: 
- Row 0: 2 
- Row 1: 4 
- Row 2: 1 
- Row 3: 2 
- Row 4: 5 
The rows ordered from weakest to strongest are [2,0,3,1,4].



mysol 90%:
class Solution:
    def kWeakestRows(self, mat: list[list[int]], k: int) -> list[int]:
        sumlist = []
        
        for i,row in enumerate(mat):
            sumlist.append([sum(row),i])
        
        sumlist.sort(key= lambda x:x[0])
        return [row[1] for row in sumlist[:k]]



100%
class Solution:
    def kWeakestRows(self, mat: list[list[int]], k: int) -> list[int]:
        d = {}
        for i in range(len(mat)):
            d[i] = sum(mat[i])
        
        return sorted(d, key=d.get)[:k]








1394. Find Lucky Integer in an Array
Given an array of integers arr, a lucky integer is an integer which has a frequency in the array equal to its value.

Return a lucky integer in the array. If there are multiple lucky integers return the largest of them. If there is no lucky integer return -1.

Example 2:
Input: arr = [1,2,2,3,3,3]
Output: 3


mysol 87%:
class Solution:
    def findLucky(self, arr: list[int]) -> int:
        currnum = 1
        longest = 1
        number  = 0
        longestnum = 0
        arr.sort()
        arr.append(-1)
        for i in range(1,len(arr)):
            # print("start:", arr[i],i)
            if arr[i]==arr[i-1]:
                currnum+=1
                # print("updated currnum to", currnum)
            else:
                if currnum == arr[i-1]:
                    # print("found lucky number",currnum)
                    if longestnum<currnum:
                        # print("updating longestnum")
                        longestnum= currnum
                # print("resetting currnum to 1")
                currnum =1
            if currnum>longest:
                longest=currnum
        if longestnum==0:
            return -1
        return longestnum


other:
from collections import defaultdict

class Solution:
    def findLucky(self, arr: list[int]) -> int:
        counter_dict = defaultdict(int)
        for num in arr:
            counter_dict[num] += 1
        counter_dict[-1] = -1
        return max(num for num, frequency in counter_dict.items() if num == frequency)


other:
from collections import defaultdict

class Solution:
    def findLucky(self, arr: list[int]) -> int:
        counts = defaultdict(int)
        for n in arr:
            counts[n] += 1
            
        luckies = [n for n in counts.keys() if counts[n]==n]
        luckies.append(-1)
        
        lucky = max(luckies)
        return lucky



other:
from collections import Counter

class Solution:
    def findLucky(self, arr: list[int]) -> int:
        counts = Counter(arr)
        return max([k for k in counts if counts[k] == k], default=-1)

all are good.




















1290. Convert Binary Number in a Linked list to Integer
Return the decimal value of the number in the linked list.


mysol:
# Definition for singly-linked list.
# class listNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def getDecimalValue(self, head: listNode) -> int:
        p = head
        l = []
        binary = 0
        while p is not None:
            l.append(p.val)
            p = p.next
        leng = len(l)
        for i in l:
            binary += (2**(leng-1))*i
            leng -= 1
        return binary


official sol:
better:
Approach 1: Binary Representation
class Solution:
    def getDecimalValue(self, head: listNode) -> int:
        num = head.val
        while head.next:
            num = num * 2 + head.next.val
            head = head.next
        return num


better:
Approach 2: Bit Manipulation
class Solution:
    def getDecimalValue(self, head: listNode) -> int:
        num = head.val
        while head.next:
            num = (num << 1) | head.next.val
            head = head.next
        return num

both time O(N) and const space




















1342. Number of Steps to Reduce a Number to Zero
Given a non-negative integer num, return the number of steps to reduce it to zero. If the current number is even, you have to divide it by 2, otherwise, you have to subtract 1 from it.

mysol: best
class Solution:
    def numberOfSteps(self, num: int) -> int:
        steps=0
        while num!=0:
            if num%2==0:
                num = num/2
                steps+=1
            else:
                num -=1
                steps+=1
        return steps









1046. Last Stone Weight
We have a collection of stones, each stone has a positive integer weight.

Each turn, we choose the two heaviest stones and smash them together.  Suppose the stones have weights x and y with x <= y.  The result of this smash is:

If x == y, both stones are totally destroyed;
If x != y, the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x.
At the end, there is at most 1 stone left.  Return the weight of this stone (or 0 if there are no stones left.)


class Solution(object):
    def lastStoneWeight(self, stones):
        stones.sort()
        while stones:
            biggest = stones.pop()
            if not stones:
                return biggest
            second = stones.pop()
            if biggest != second:
                stones.append(biggest - second)
                stones.sort()
        
        return 0

mysol: 
class Solution:
    def lastStoneWeight(self, stones: list[int]) -> int:
        for i in range(1,len(stones)):
            one = max(stones)
            stones.remove(one)
            other = max(stones)
            stones.remove(other)
            stones.append(one-other)
            
        return stones[0]















1046. Last Stone Weight
We have a collection of stones, each stone has a positive integer weight.

Each turn, we choose the two heaviest stones and smash them together.  Suppose the stones have weights x and y with x <= y.  The result of this smash is:

If x == y, both stones are totally destroyed;
If x != y, the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x.
At the end, there is at most 1 stone left.  Return the weight of this stone (or 0 if there are no stones left.)


class Solution(object):
    def lastStoneWeight(self, stones):
        stones.sort()
        while stones:
            biggest = stones.pop()
            if not stones:
                return biggest
            second = stones.pop()
            if biggest != second:
                stones.append(biggest - second)
                stones.sort()
        
        return 0

mysol: 
class Solution:
    def lastStoneWeight(self, stones: list[int]) -> int:
        for i in range(1,len(stones)):
            one = max(stones)
            stones.remove(one)
            other = max(stones)
            stones.remove(other)
            stones.append(one-other)
            
        return stones[0]

















1089. Duplicate Zeros
Given a fixed length array arr of integers, duplicate each occurrence of zero, shifting the remaining elements to the right.

Note that elements beyond the length of the original array are not written.

Do the above modifications to the input array in place, do not return anything from your function.

mysol:
class Solution:
    def duplicateZeros(self, arr: list[int]) -> None:
        """
        Do not return anything, modify arr in-place instead.
        """
        i=0
        while i<len(arr):
            if not arr[i]:
                arr.insert(i, 0)
                arr.pop()
                i +=1
            i+=1


best:

Find the number of zeros which would be duplicated. Let's call it possible_dups. We do need to make sure we are not counting the zeros which would be trimmed off. Since, the discarded zeros won't be part of the final array. The count of possible_dups would give us the number of elements to be trimmed off the original array. Hence at any point, length_ - possible_dups is the number of elements which would be included in the final array.

Note: In the diagram above we just show source and destination array for understanding purpose. We will be doing these operations only on one array.
Handle the edge case for a zero present on the boundary of the leftover elements.

Let's talk about the edge case of this problem. We need to be extra careful when we are duplicating the zeros in the leftover array. This care should be taken for the zero which is lying on the boundary. Since, this zero might be counted as with possible duplicates, or may be just got included in the left over when there was no space left to accommodate its duplicate. If it is part of the possible_dups we would want to duplicate it otherwise we don't.

An example of the edge case is - [8,4,5,0,0,0,0,7]. In this array there is space to accommodate the duplicates of first and second occurrences of zero. But we don't have enough space for the duplicate of the third occurrence of zero. Hence when we are copying we need to make sure for the third occurrence we don't copy twice. Result = [8,4,5,0,0,0,0,0]

Iterate the array from the end and copy a non-zero element once and zero element twice. When we say we discard the extraneous elements, it simply means we start from the left of the extraneous elements and start overwriting them with new values, eventually right shifting the left over elements and creating space for all the duplicated elements in the array.


class Solution:
    def duplicateZeros(self, arr: list[int]) -> None:
        """
        Do not return anything, modify arr in-place instead.
        """

        possible_dups = 0
        length_ = len(arr) - 1

        # Find the number of zeros to be duplicated
        for left in range(length_ + 1):

            # Stop when left points beyond the last element in the original list
            # which would be part of the modified list
            if left > length_ - possible_dups:
                break

            # Count the zeros
            if arr[left] == 0:
                # Edge case: This zero can't be duplicated. We have no more space,
                # as left is pointing to the last element which could be included  
                if left == length_ - possible_dups:
                    arr[length_] = 0 # For this zero we just copy it without duplication.
                    length_ -= 1
                    break
                possible_dups += 1

        # Start backwards from the last element which would be part of new list.
        last = length_ - possible_dups

        # Copy zero twice, and non zero once.
        for i in range(last, -1, -1):
            if arr[i] == 0:
                arr[i + possible_dups] = 0
                possible_dups -= 1
                arr[i + possible_dups] = 0
            else:
                arr[i + possible_dups] = arr[i]









1848. Minimum Distance to the Target Element
Given an integer array nums (0-indexed) and two integers target and start, find an index i such that nums[i] == target and abs(i - start) is minimized. Note that abs(x) is the absolute value of x.
Return abs(i - start).
It is guaranteed that target exists in nums.

mysol: 96%
class Solution:
    def getMinDistance(self, nums: list[int], target: int, start: int) -> int:
        distance = 1
        left  = start - 1
        right = start + 1
        if nums[start] == target:
            return 0
        while left>=0 and right<len(nums):
            if nums[left]==target or nums[right]==target:
                return distance
            else:
                left -=1
                right+=1
                distance +=1
        
        indices = [i for i, x in enumerate(nums) if x == target]
        if left<0:
            return min(indices)+distance-right
        if right>=len(nums):
            return left-max(indices)+distance









1837. Sum of Digits in Base K
Given an integer n (in base 10) and a base k, return the sum of the digits of n after converting n from base 10 to base k.

After converting, each digit should be interpreted as a base 10 number, and the sum should be returned in base 10.

mysol
class Solution:
    def sumBase(self, n: int, k: int) -> int:
        ans = [0]*7        #cos constraints tell us max is 100 in base 2, which is 7 digits
        i = 0
        while n > 0:
            ans[i] = n % k
            n //= k
            i +=1         
            
        print(ans)
        res = 0
        for a in ans:
            res+=int(a)
        return res
        

mysol (better) 99.47, 80%:
class Solution:
    def sumBase(self, n: int, k: int) -> int:
        sum = 0
        while n > 0:
            sum += n % k
            n //= k
        return sum









1832. Check if the Sentence Is Pangram

mysol:
class Solution:
    def checkIfPangram(self, sentence: str) -> bool:
        sett = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'}
        for s in sentence:
            try:
                sett.remove(s)
            except:
                pass
            
        if len(sett)==0:
            return True
        else:
            return False

similar but simple:
comp = set()
for i in sentence:
   comp.add(i)
        
if len(comp) == 26:
    return True
    
return False















1844. Replace All Digits with Characters
You are given a 0-indexed string s that has lowercase English letters in its even indices and digits in its odd indices.

There is a function shift(c, x), where c is a character and x is a digit, that returns the xth character after c.

For example, shift('a', 5) = 'f' and shift('x', 0) = 'x'.
For every odd index i, you want to replace the digit s[i] with shift(s[i-1], s[i]).

mysol 99.4%:
class Solution:
    def shift(self, char:str, x: int):
        return chr(ord(char)+x)
    
    def replaceDigits(self, s: str) -> str:
        # shift(char, x) returns xth character after char
        lis = [i for i in s]
        for i in range(1, len(lis), 2):
            lis[i] = self.shift(lis[i-1], int(lis[i]))
        return ''.join(lis)











20. Valid Parentheses
Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

An input string is valid if:

Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.


mysol 86%:
class Solution:
    def match(self, bracket):
        if bracket == ")":
            return "("
        elif bracket == "}":
            return "{"
        elif bracket == "]":
            return "["
        
    def isValid(self, s: str) -> bool:
        stack = []
        for brac in s:
            if brac=="(" or brac=="[" or brac=="{": 
                stack.append(brac)
                            
            elif (brac==")" or brac=="]" or brac=="}"):
                if len(stack)==0:
                    return False
                elif self.match(brac) == stack[-1]:
                    stack.pop()
                else:
                    return False
        if not len(stack)==0:
            return False
        return True


official sol time same syntax better and simple:
class Solution(object):
    def isValid(self, s):
        """
        :type s: str
        :rtype: bool
        """

        # The stack to keep track of opening brackets.
        stack = []

        # Hash map for keeping track of mappings. This keeps the code very clean.
        # Also makes adding more types of parenthesis easier
        mapping = {")": "(", "}": "{", "]": "["}

        # For every bracket in the expression.
        for char in s:

            # If the character is an closing bracket
            if char in mapping:

                # Pop the topmost element from the stack, if it is non empty
                # Otherwise assign a dummy value of '#' to the top_element variable
                top_element = stack.pop() if stack else '#'

                # The mapping for the opening bracket in our hash and the top
                # element of the stack don't match, return False
                if mapping[char] != top_element:
                    return False
            else:
                # We have an opening bracket, simply push it onto the stack.
                stack.append(char)

        return not stack



other sol:
def isValid(self, s):
    bracket_map = {"(": ")", "[": "]",  "{": "}"}
    open_par = set(["(", "[", "{"])
    stack = []
    for i in s:
        if i in open_par:
            stack.append(i)
        elif stack and i == bracket_map[stack[-1]]:
                stack.pop()
        else:
            return False
    return stack == []
















53. Maximum Subarray
Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.


mysol:
class Solution:
    def maxSubArray(self, nums: list[int]) -> int:
        ans=[]
        ans.append(nums[0])
        for i in range(1,len(nums)):
            ans.append(max(nums[i],ans[i-1]+nums[i]))
        
        return max(ans)


best:
class Solution:
    def maxSubArray(self, nums: list[int]) -> int:
        """
Kadane's algorithm: At every index, see if we get better result by adding the element to the current sequence or starting a new sequence.
nums = [-2,1,-3,4,-1,2,1,-5,4]
current sequence: [-2], current sum = -2
Do we get better result by adding 1 to sequence: [-2, 1] = -1
OR do we get better result by starting sequence at 1: [1] = 1
Just take the max of those two as current sum, and update max sum as you go
        """
        curr_sum = max_sum = nums[0]
        for num in nums[1:]:
            curr_sum = max(curr_sum + num, num)
            max_sum = max(max_sum, curr_sum)
        return max_sum


class Solution:
    def maxSubArray(self, nums: list[int]) -> int:
        maxE = 0
        maxS = -math.inf
        
        for ele in nums:
            maxE += ele
            if maxS < maxE:
                maxS = maxE
            if maxE < 0:
                maxE = 0
        return maxS



















1351. Count Negative Numbers in a Sorted Matrix

Given a m x n matrix grid which is sorted in non-increasing order both row-wise and column-wise, return the number of negative numbers in grid.

mysol 98%:
class Solution:
    def countNegatives(self, grid: list[list[int]]) -> int:
        m = len(grid)-1
        n = len(grid[0])-1
        j = n
        i = 0
        c = 0
        while i<=m and j>=0:
            if grid[i][j]<0:
                # print("found at", i,j, "adding", m-i+1)
                j -= 1
                c += m-i+1
            else:
                i +=1
        return c


We can optimize more by using binary search to search the first the index in every row.
Time: O(nlogm)
Python solution:

class Solution:
    def firstIndex(self, arr):
        start = 0
        end = len(arr) -1
        count = 0
        location = -1
        while start <= end:
            mid = start + (end - start)//2
            if (arr[mid] < 0):
                location = mid
                end = mid - 1;
            else:
                start = mid + 1
        return location
    def countNegatives(self, grid: list[list[int]]) -> int:
        row = len(grid)
        col = len(grid[0])
        i = 0
        j = 0
        count = 0
        while i < row:
            first = self.firstIndex(grid[i])
            if first >= 0:
                count += (col - first)
                i += 1
            else:
                i += 1
        return count


another using binary search:
class Solution(object):
    def countNegatives(self, grid: list[list[int]]) -> int:
        def find_negative(row):
            left, right = 0, len(row)
            while left<right:
                mid = left + (right-left) // 2
                if row[mid]<0:
                    right = mid
                else:
                    left = mid+1
            return len(row)- left
        
        count = 0
        for i in grid:
            count += find_negative(i)
        return(count)


























118. Pascal's Triangle
Given an integer numRows, return the first numRows of Pascal's triangle.

mysol:
class Solution:
    def generate(self, numRows: int) -> list[list[int]]:
        tri = list()
        tri.append([1])
        rownum = 2
        
        while rownum<=numRows:
            subtri = [1]
            for i in range(1, rownum-1):
                subtri.append(tri[-1][i-1]+tri[-1][i])
            subtri.append(1)
            tri.append(subtri)
            rownum +=1
        return tri

#could be faster when assignment is used instead of append.

class Solution:
    def generate(self, num_rows):
        triangle = []

        for row_num in range(num_rows):
            # The first and last row elements are always 1.
            row = [None for _ in range(row_num+1)]
            row[0], row[-1] = 1, 1

            # Each triangle element is equal to the sum of the elements
            # above-and-to-the-left and above-and-to-the-right.
            for j in range(1, len(row)-1):
                row[j] = triangle[row_num-1][j-1] + triangle[row_num-1][j]

            triangle.append(row)

        return triangle

#both solutions, O(n^2) for time and space.












119. Pascal's Triangle II
Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal's triangle.

mysol:
class Solution:
    def getRow(self, rowIndex: int) -> list[int]:
        #direct approch would be and return the last row.
        
        #this approch does it in O(n) time
        prev = 1
        ans = [None]*(rowIndex+1)
        ans[0] = 1
        for i in range(1,rowIndex+1):            
            curr = (prev * (rowIndex - i + 1)) // i
            ans[i] = curr
            prev = curr
        return ans

#could also be done more simply with append, this is faster ig


















125. Valid Palindrome
Given a string s, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.


mysol:
class Solution:
    def isPalindrome(self, s: str) -> bool:
        #one way is stack, we first go to half the string, and append each char to a list. if the len is odd, we ingore the first element in second pass, (the later half pass) now, in the second half pass, we match every element. if doesnt matches or the stack is not empty by the end, its not a palindrome.  O(n)
        #Other way two pointer approach, at any time is they dont match, return False. use a while loop
        
        #slicing the string would be better than stack approch ig. 
        
        # slicing:
#         firsthalf = s[:len(s)//2]
#         laterhalf = s[len(s)//2+1:]
        
        # but we have contraints here, we consider only alphanumeric, so this wont work. and string is immutable too.
        
        # now the stack feels better approach. 
        # but lets try two pointer approch
        i=0
        j=len(s)-1
        while i<=j:
            if not s[i].isalnum():
                i +=1
                continue
            if not s[j].isalnum():
                j -=1
                continue
            if s[i].lower()==s[j].lower():
                i +=1
                j -=1
            else:
                return False
        return True
    
    
    
    #thats a correct (tested) two pointer approach   57%, though, memory better than 94% though
    # now lets check the stack approach
    
    #not working theres some problem with length/
    
#         stack = []
#         leng = 0
#         for c in s:
#             if not c.isalnum():
#                 continue
#             leng+=1
        
#         for f in s[:leng//2]:
#             if not f.isalnum():
#                 continue
#             stack.append(f)
#         print(stack)
        
#         for e in s[leng//2+1:]:
#             if not e.isalnum():
#                 continue
#             print("comparing:", e, ":with last of:", stack)
#             if e.lower() == stack[-1].lower():
#                 stack.pop()
#             else:
#                 return False
#         print(stack)
#         if not stack:
#             return True
#         return False



best:
class Solution:
    def isPalindrome(self, s: str) -> bool:
        
        l = len(s)
        i = 0
        j = l - 1
        if not any(map(str.isalnum, s)): return True
        while True:
            while not s[i].isalnum():
                i += 1
                #if i == l: return True
            while not s[j].isalnum():
                j -= 1
                #if j < 0: return True
            if i >= j: return True
            if not (s[i] == s[j] or s[i] == chr(ord(s[j]) ^ 32)): return False
            i += 1
            j -= 1
            
        return True

























121. Best Time to Buy and Sell Stock
IMPORTant, 5 levels of same question. read the solution

You are given an array prices where prices[i] is the price of a given stock on the ith day.

You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.

Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.

mysol:  timelimitexceeded
brute force
class Solution:
    def maxProfit(self, prices: list[int]) -> int:
        #O(n^2)
        profit = 0
        i = len(prices)-1
        while i:
            for price in prices[:i]:
                if profit<prices[i]-price:
                    profit = prices[i]-price
            i -=1
        
        return profit


offciail brute force sol: java, timelimitexceeded
public class Solution {
    public int maxProfit(int prices[]) {
        int maxprofit = 0;
        for (int i = 0; i < prices.length - 1; i++) {
            for (int j = i + 1; j < prices.length; j++) {
                int profit = prices[j] - prices[i];
                if (profit > maxprofit)
                    maxprofit = profit;
            }
        }
        return maxprofit;
    }
}


better: onepass:O(n)
The points of interest are the peaks and valleys in the given graph. We need to find the largest peak following the smallest valley. We can maintain two variables - minprice and maxprofit corresponding to the smallest valley and maximum profit (maximum difference between selling price and minprice) obtained so far respectively.

public class Solution {
    public int maxProfit(int prices[]) {
        int minprice = Integer.MAX_VALUE;
        int maxprofit = 0;
        for (int i = 0; i < prices.length; i++) {
            if (prices[i] < minprice)
                minprice = prices[i];
            else if (prices[i] - minprice > maxprofit)
                maxprofit = prices[i] - minprice;
        }
        return maxprofit;
    }
}














168. Excel Sheet Column Title
Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet.

Input: columnNumber = 28
Output: "AB"

Input: columnNumber = 701
Output: "ZY"

class Solution:
    def convertToTitle(self, columnNumber: int) -> str:
        nums = range(1, 27)
        letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
        
        mapp = dict(zip(nums, letters))
        
        q = 1
        n = columnNumber
        title = []
        while q > 0:
            q = n // 26
            r = n % 26
            if r == 0:
                r = 26
                q -= 1
                
            title.insert(0, mapp[r])
            n = q
        return ''.join(title)











*important
169. Majority Element
Given an array nums of size n, return the majority element.

The majority element is the element that appears more than âŒŠn / 2âŒ‹ times. You may assume that the majority element always exists in the array.

mysol: 97%
class Solution:
    def majorityElement(self, nums: list[int]) -> int:
        l = len(nums)//2
        dic = {}
        for n in nums:
            dic[n] = dic.get(n, 0) + 1
        return max(dic, key=dic.get)


Approach 1: Brute Force

class Solution:
    def majorityElement(self, nums):
        majority_count = len(nums)//2
        for num in nums:
            count = sum(1 for elem in nums if elem == num)
            if count > majority_count:
                return num

Algorithm
The brute force algorithm iterates over the array, and then iterates again for each number to count its occurrences. As soon as a number is found to have appeared more than any other can possibly have appeared, return it.
O(n^2), O(1) 



Approach 2: HashMap

class Solution:
    def majorityElement(self, nums):
        counts = collections.Counter(nums)
        return max(counts.keys(), key=counts.get)

O(n) O(n)



Approach 3: 

class Solution:
    def majorityElement(self, nums):
        nums.sort()
        return nums[len(nums)//2]

O(nlogn), O(1) or O(n) depending whether we store the array.



Approach 4: Randomization

Because a given index is likely to have the majority element, we can just select a random index, check whether its value is the majority element, return if it is, and repeat if it is not. The algorithm is verifiably correct because we ensure that the randomly chosen value is the majority element before ever returning.

import random

class Solution:
    def majorityElement(self, nums):
        majority_count = len(nums)//2
        while True:
            candidate = random.choice(nums)
            if sum(1 for elem in nums if elem == candidate) > majority_count:
                return candidate


worst case is legit O(inf)
avg case or expected case is O(n)
O(1) for space



Approach 5: Divide and Conquer

1. Here, we apply a classical divide & conquer approach 
2. that recurses on the left and right halves of an array until an answer can be trivially achieved for a length-1 array.
3. Note that because actually passing copies of subarrays costs time and space, we instead pass lo and hi indices that describe the relevant slice of the overall array.
4. In this case, the majority element for a length-1 slice is trivially its only element, so the recursion stops there. 
5. If the current slice is longer than length-1, we must combine the answers for the slice's left and right halves. 
6. If they agree on the majority element, then the majority element for the overall slice is obviously the same. 
7. If they disagree, only one of them can be "right", so we need to count the occurrences of the left and right majority elements to determine which subslice's answer is globally correct. 
8. The overall answer for the array is thus the majority element between indices 0 and n.

class Solution:
    def majorityElement(self, nums, lo=0, hi=None):
        def majority_element_rec(lo, hi):
            # base case; the only element in an array of size 1 is the majority
            # element.
            if lo == hi:
                return nums[lo]

            # recurse on left and right halves of this slice.
            mid = (hi-lo)//2 + lo
            left = majority_element_rec(lo, mid)
            right = majority_element_rec(mid+1, hi)

            # if the two halves agree on the majority element, return it.
            if left == right:
                return left

            # otherwise, count each element and return the "winner".
            left_count = sum(1 for i in range(lo, hi+1) if nums[i] == left)
            right_count = sum(1 for i in range(lo, hi+1) if nums[i] == right)

            return left if left_count > right_count else right

        return majority_element_rec(0, len(nums)-1)



O(nlogn)
O(lgn)





***
Approach 6: Boyer-Moore Voting Algorithm
Intuition:
If we had some way of counting instances of the majority element as +1 and instances of any other element as -1, summing them would make it obvious that the majority element is indeed the majority element.

algorithm:
1. Essentially, what Boyer-Moore does is look for a suffix sufsuf of nums where suf[0]suf[0] is the majority element in that suffix. To do this, we maintain a count, which is incremented whenever we see an instance of our current candidate for majority element and decremented whenever we see anything else.

2. Whenever count equals 0, we effectively forget about everything in nums up to the current index and consider the current number as the candidate for majority element.

3. It is not immediately obvious why we can get away with forgetting prefixes of nums - consider the following examples (pipes are inserted to separate runs of nonzero count).

[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]

4. Here, the 7 at index 0 is selected to be the first candidate for majority element. count will eventually reach 0 after index 5 is processed, so the 5 at index 6 will be the next candidate. 

5.  In this case, 7 is the true majority element, so by disregarding this prefix, we are ignoring an equal number of majority and minority elements - therefore, 7 will still be the majority element in the suffix formed by throwing away the first prefix.

[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 5, 5, 5, 5]

6. Now, the majority element is 5 (we changed the last run of the array from 7s to 5s), but our first candidate is still 7.

7. In this case, our candidate is not the true majority element, but we still cannot discard more majority elements than minority elements (this would imply that count could reach -1 before we reassign candidate, which is obviously false).

8. Therefore, given that it is impossible (in both cases) to discard more majority elements than minority elements, we are safe in discarding the prefix and attempting to recursively solve the majority element problem for the suffix. 

9. Eventually, a suffix will be found for which count does not hit 0, and the majority element of that suffix will necessarily be the same as the majority element of the overall array.

class Solution:
    def majorityElement(self, nums):
        count = 0
        candidate = None

        for num in nums:
            if count == 0:
                candidate = num
            count += (1 if num == candidate else -1)

        return candidate

its O(n), O(1)




















172. Factorial Trailing Zeroes
Given an integer n, return the number of trailing zeroes in n!.
Follow up: Could you write a solution that works in logarithmic time complexity?

class Solution:
    def trailingZeroes(self, n: int) -> int:
        # Trailing 0s in n! = Count of 5s in prime factors of n!
        #                   = floor(n/5) + floor(n/25) + floor(n/125) + ....
        i=5
        count = 0
        while (n / i>= 1):
            count += n // i
            i *= 5
        return count

similar:
class Solution:
    def trailingZeroes(self, n: int) -> int:
        count = 0
 
    # Keep dividing n by
    # 5 & update Count
        while(n >= 5):
            n //= 5
            count += n

        return count








233. Number of Digit One
Hard
Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.

mysol: 
class Solution:
    def countDigitOne(self, n: int) -> int:
        count = 0
        i = 1
        while(i <= n):
            j = i * 10
            count += ((n // j) * i + min(max(n % j -i + 1, 0), i))
            i *= 10

        return count

Approach #2 Solve it mathematically
Iterate over i from 1 to n incrementing by 10 each time:

Add (n/(i*10))*i to countr representing the repetition of groups of i sizes after each (i*10) interval.

Add min(max((n mod (i*10)) - i + 1 ,0),i) to countr representing the additional digits dependant on the digit in iith place as described in intuition.

C++
int countDigitOne(int n)
{
    int countr = 0;
    for (long long i = 1; i <= n; i *= 10) {
        long long divider = i * 10;
        countr += (n / divider) * i + min(max(n % divider - i + 1, 0LL), i);
    }
    return countr;
}

(Thats what I did.)
O(log10(n)), O(1)

better:
class Solution:
    def countDigitOne(self, n: int) -> int:
        res = 0
        divisor = 10
        while True:
            q, r1 = divmod(n, divisor)
            b, r2 = divmod(r1, (divisor // 10))
            if b > 1:
                incre = q * (divisor // 10) + divisor // 10
            elif b == 1:
                incre = q * (divisor // 10) + r2 + 1
            else:
                incre = (q - 1) * (divisor // 10) +  divisor // 10
            res += incre
            if q == 0:
                break
            divisor *= 10
        return res
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	#rest
	class Solution:
    def backspaceCompare(self, s: str, t: str) -> bool:
        sp = 0
        tp = 0
        
        while sp<=len(s) or tp<=len(t):
            print("start", s[sp], t[tp]) 
            if s[sp+1]=='#':
                sp+=1
                print("skiping sp+1", s[sp], t[tp])
            elif t[tp+1]=='#':
                print("skiping tp+1", s[sp], t[tp])
                tp+=1
            elif s[sp]=='#':
                print("skiping # in s", s[sp], t[tp])
                sp+=1
            elif t[tp]=='#':
                print("skiping # in t", s[sp], t[tp])
                tp+=1
            else:
                print("comp", s[sp], t[tp])
                if s[sp]==t[tp]:
                    sp +=1
                    tp +=1
                else:
                    return False
            print()
        return True
